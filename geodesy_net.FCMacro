import os
import re
import pandas as pd
import numpy as np
import math
from scipy.spatial import Delaunay, KDTree
import FreeCAD, FreeCADGui
import Draft
import shutil
import Part
from PySide2.QtWidgets import QDialog, QVBoxLayout, QFormLayout, QLineEdit, QComboBox, QSpinBox, QCheckBox, QPushButton, QFileDialog, QTextEdit
from PySide2.QtGui import QFont


class MyWindow(QDialog):
    def __init__(self):
        super().__init__()

        self.points_amount = None  # кол-во пунктов
        self.gen_method = None     # метод генерации
        #self.gen_radius = None     # Радиус генерации (относительно стартового пункта)
        self.min_distance = None   # Минимальное расстояние между пунктами
        self.max_distance = None   # Максимальное расстояние между пунктами
        self.reference_coords_X = None
        self.reference_coords_Y = None

        self.temp_file_xyz_name = ''  # Переменные для хранения имен временных файлов
		
        folder_name = 'Data'  # Папка для временных файлов и сохранения
       	
        if not os.path.exists(folder_name):  # Проверяем наличие папки Data
            os.makedirs(folder_name)
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))  # Определяем расположение директории
            self.data_dir = os.path.join(self.script_dir, 'Data')  # Определяем расположения папки для файлов

        self.createUI()

    def createUI(self):
        layout = QVBoxLayout()

        form_layout = QFormLayout()

        self.points_spinbox = QSpinBox()
        self.points_spinbox.setRange(3, 100)
        self.points_spinbox.setSingleStep(1)
        self.points_spinbox.setValue(10)
        self.method_input = QComboBox()
        self.method_input.addItems(['centralized', 'consistent'])
        #self.gen_radius_input = QLineEdit()
        #self.gen_radius_input.setText('0.5')

        self.reference_coords_X_textbox = QLineEdit()
        self.reference_coords_X_textbox.setText('10')
        self.reference_coords_Y_textbox = QLineEdit()
        self.reference_coords_Y_textbox.setText('10')

        self.min_distance_input = QLineEdit()
        self.min_distance_input.setText('20000')
        self.max_distance_input = QLineEdit()
        self.max_distance_input.setText('30000')

        form_layout.addRow('Num of points:', self.points_spinbox)
        form_layout.addRow('Generation method:', self.method_input)
        #form_layout.addRow('Gen radius (deg):', self.gen_radius_input)
        form_layout.addRow('Min distance (m):', self.min_distance_input)
        form_layout.addRow('Max distance (m):', self.max_distance_input)
        form_layout.addRow('Reference coordinate X:', self.reference_coords_X_textbox)
        form_layout.addRow('Reference coordinate Y:', self.reference_coords_Y_textbox)

        layout.addLayout(form_layout)

        self.create_button = QPushButton('Create')
        self.create_button.clicked.connect(self.btn1_press)
        layout.addWidget(self.create_button)

        self.show_network_button = QPushButton('Show network map')
        self.show_network_button.clicked.connect(self.btn2_press)
        layout.addWidget(self.show_network_button)

        self.save_button = QPushButton('Save to file')
        self.save_button.clicked.connect(self.btn3_press)
        layout.addWidget(self.save_button)

        self.load_csv_button = QPushButton('Load CSV')
        self.load_csv_button.clicked.connect(self.load_csv_file)
        layout.addWidget(self.load_csv_button)

        self.command_line = QTextEdit(self)
        self.command_line.setStyleSheet("background-color: black; color: white;")
        self.command_line.setFont(QFont("Courier", 10))
        layout.addWidget(self.command_line)

        self.setLayout(layout)
        self.setWindowTitle('Synthetic TimeSeries data app')
        #self.showMaximized()

    def load_csv_file(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self, "Load CSV Data File", "", "CSV Files (*.csv)", options=options)
        if file_name:
            self.temp_file_xyz_name = file_name
            self.command_line.append(f"CSV Data File loaded: {self.temp_file_xyz_name}")

    def btn1_press(self):
        self.command_line.append('Creating model...')
        
        self.points_amount = self.points_spinbox.value()
        self.gen_method = self.method_input.currentText()
        #self.gen_radius = float(self.gen_radius_input.text())
        self.min_distance = int(self.min_distance_input.text())
        self.max_distance = int(self.max_distance_input.text())
        self.reference_coords_X = float(self.reference_coords_X_textbox.text())
        self.reference_coords_Y = float(self.reference_coords_Y_textbox.text())

        points = self.create_random_points()
        self.generate_time_series(points)

        self.command_line.append("Model created")

    def create_random_points(self):
	
        if self.min_distance > self.max_distance:
            raise ValueError("Minimum distance cannot be greater than maximum distance")
        
        points = []
        # Generate the first point 
         
        points.append((self.reference_coords_X , self.reference_coords_Y ))

        for i in range(1, self.points_amount):
            # Generate a random direction (angle in radians)
            direction = np.random.uniform(0, 2 * math.pi)

            # Generate a random distance within the specified range
            distance = np.random.uniform(self.min_distance, self.max_distance)

            # Calculate the new point's coordinates
            prev_x, prev_y = points[-1]
            new_x = prev_x + distance * math.cos(direction)
            new_y = prev_y + distance * math.sin(direction)

            points.append((new_x, new_y))

        return points

    def generate_time_series(self, points):
        data = []

        for i, point in enumerate(points):
            lat, lon = point
            station_name = ''.join(np.random.choice(list('ABCDEFGHIJKLMNOPQRSTUVWXYZ'), 4))

            height = np.random.uniform(0, 100)

            data.append({'Station': station_name,
                         'Latitude': lat,
                         'Longitude': lon,
                         'Height': height})

        df = pd.DataFrame(data)
        self.temp_file_xyz_name = os.path.join(self.data_dir, 'temp_xyz.csv')
        df.to_csv(self.temp_file_xyz_name, sep=';', index=False)

        self.command_line.append(f"Time series generated and saved to file: {self.temp_file_xyz_name}")

    def btn2_press(self):
        try:
            if not self.temp_file_xyz_name:
                self.command_line.append("No CSV file loaded. Please load a CSV file first.")
                return

            doc = FreeCAD.newDocument("NetworkMap")
            data = pd.read_csv(self.temp_file_xyz_name, delimiter=';')

            points = np.array(data[['Longitude', 'Latitude']])
            labels = data['Station'].astype(str).values

            tri = Delaunay(points)

            max_vector_length = 1000000  # adjust this value to set the maximum vector length

            for simplex in tri.simplices:
                point1 = points[simplex[0]]
                point2 = points[simplex[1]]
                point3 = points[simplex[2]]

                # Calculate the lengths of the vectors
                length12 = self.calculate_distance(point1[0], point1[1], point2[0], point2[1])
                length23 = self.calculate_distance(point2[0], point2[1], point3[0], point3[1])
                length31 = self.calculate_distance(point3[0], point3[1], point1[0], point1[1])

                if length12 <= max_vector_length and length23 <= max_vector_length and length31 <= max_vector_length:
                    polygon = Part.makePolygon([FreeCAD.Vector(point1[0], point1[1], 0),
                                                FreeCAD.Vector(point2[0], point2[1], 0),
                                                FreeCAD.Vector(point3[0], point3[1], 0),
                                                FreeCAD.Vector(point1[0], point1[1], 0)])
                    Part.show(polygon)

                    # Add text labels for the vector lengths
                    midpoint12 = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, 0)
                    text12 = Draft.make_text([f"{length12:.0f} m"], FreeCAD.Vector(*midpoint12))
                    if text12 is not None:
                        text12.ViewObject.FontSize = 0.02

                    midpoint23 = ((point2[0] + point3[0]) / 2, (point2[1] + point3[1]) / 2, 0)
                    text23 = Draft.make_text([f"{length23:.0f} m"], FreeCAD.Vector(*midpoint23))
                    if text23 is not None:
                        text23.ViewObject.FontSize = 1000

                    midpoint31 = ((point3[0] + point1[0]) / 2, (point3[1] + point1[1]) / 2, 0)
                    text31 = Draft.make_text([f"{length31:.0f} m"], FreeCAD.Vector(*midpoint31))
                    if text31 is not None:
                        text31.ViewObject.FontSize = 1000

            for i, point in enumerate(points):
                label = labels[i]
                
                offset = FreeCAD.Vector(0.01, 0.01, 0)
                text_position = FreeCAD.Vector(point[0], point[1], 0) + offset
                text = Draft.make_text([label], text_position)
                if text is not None:
                    text.ViewObject.FontSize = 2000  # Размер шрифта названий пунктов

            FreeCADGui.activeDocument().activeView().viewAxometric()
            FreeCADGui.SendMsgToActiveView("ViewFit")
        except Exception as e:
            self.command_line.append(f'Error generating network map: {e}')

    def btn3_press(self):
        try:
            save_path, _ = QFileDialog.getSaveFileName(self, "Save File", "", "CSV Files (*.csv)")
            if save_path:
                shutil.copyfile(self.temp_file_xyz_name, save_path)
                self.command_line.append("File saved.")
        except Exception as e:
            self.command_line.append(f'Error saving file: {e}')

    def calculate_distance(self, x1, y1, x2, y2):
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

if __name__ == '__main__':
    main_window = MyWindow()
    main_window.exec_()
