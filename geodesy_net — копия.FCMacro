import os
import re
import pandas as pd
import numpy as np
import math
from scipy.spatial import Delaunay, KDTree
import FreeCAD, FreeCADGui
import Draft
import shutil
import Part
from PySide2.QtWidgets import QDialog, QVBoxLayout, QFormLayout, QLineEdit, QComboBox, QSpinBox, QCheckBox, QPushButton, QFileDialog, QTextEdit
from PySide2.QtGui import QFont

class MyWindow(QDialog):
    def __init__(self):
        super().__init__()

        self.points_amount = None  # кол-во пунктов
        self.gen_method = None     # метод генерации
        #self.gen_radius = None     # Радиус генерации (относительно стартового пункта)
        self.min_distance = None   # Минимальное расстояние между пунктами
        self.max_distance = None   # Максимальное расстояние между пунктами
        self.reference_coords_X = None
        self.reference_coords_Y = None

        self.temp_file_xyz_name = ''  # Переменные для хранения имен временных файлов
		
        folder_name = 'Data'  # Папка для временных файлов и сохранения
       	
        if not os.path.exists(folder_name):  # Проверяем наличие папки Data
            os.makedirs(folder_name)
        else:
            self.script_dir = os.path.dirname(os.path.abspath(__file__))  # Определяем расположение директории
            self.data_dir = os.path.join(self.script_dir, 'Data')  # Определяем расположения папки для файлов

        self.createUI()

    def createUI(self):
        layout = QVBoxLayout()

        form_layout = QFormLayout()

        self.points_spinbox = QSpinBox()
        self.points_spinbox.setRange(3, 100)
        self.points_spinbox.setSingleStep(1)
        self.points_spinbox.setValue(10)
        self.method_input = QComboBox()
        self.method_input.addItems(['centralized', 'consistent'])
        #self.gen_radius_input = QLineEdit()
        #self.gen_radius_input.setText('0.5')

        self.reference_coords_X_textbox = QLineEdit()
        self.reference_coords_X_textbox.setText('10')
        self.reference_coords_Y_textbox = QLineEdit()
        self.reference_coords_Y_textbox.setText('10')

        self.min_distance_input = QLineEdit()
        self.min_distance_input.setText('20000')
        self.max_distance_input = QLineEdit()
        self.max_distance_input.setText('30000')

        form_layout.addRow('Num of points:', self.points_spinbox)
        form_layout.addRow('Generation method:', self.method_input)
        #form_layout.addRow('Gen radius (deg):', self.gen_radius_input)
        form_layout.addRow('Min distance (m):', self.min_distance_input)
        form_layout.addRow('Max distance (m):', self.max_distance_input)
        form_layout.addRow('Reference coordinate X:', self.reference_coords_X_textbox)
        form_layout.addRow('Reference coordinate Y:', self.reference_coords_Y_textbox)

        layout.addLayout(form_layout)

        self.create_button = QPushButton('Create')
        self.create_button.clicked.connect(self.btn1_press)
        layout.addWidget(self.create_button)

        self.show_network_button = QPushButton('Show network map')
        self.show_network_button.clicked.connect(self.btn2_press)
        layout.addWidget(self.show_network_button)

        self.save_button = QPushButton('Save to file')
        self.save_button.clicked.connect(self.btn3_press)
        layout.addWidget(self.save_button)

        self.load_csv_button = QPushButton('Load CSV')
        self.load_csv_button.clicked.connect(self.load_csv_file)
        layout.addWidget(self.load_csv_button)

        self.command_line = QTextEdit(self)
        self.command_line.setStyleSheet("background-color: black; color: white;")
        self.command_line.setFont(QFont("Courier", 10))
        layout.addWidget(self.command_line)

        self.setLayout(layout)
        self.setWindowTitle('Synthetic TimeSeries data app')
        #self.showMaximized()

    def load_csv_file(self):
        options = QFileDialog.Options()
        file_name, _ = QFileDialog.getOpenFileName(self, "Load CSV Data File", "", "CSV Files (*.csv)", options=options)
        if file_name:
            self.temp_file_xyz_name = file_name
            self.command_line.append(f"CSV Data File loaded: {self.temp_file_xyz_name}")

    def btn1_press(self):
        self.command_line.append('Creating model...')
        
        self.points_amount = self.points_spinbox.value()
        self.gen_method = self.method_input.currentText()
        #self.gen_radius = float(self.gen_radius_input.text())
        self.min_distance = int(self.min_distance_input.text())
        self.max_distance = int(self.max_distance_input.text())
        self.reference_coords_X = float(self.reference_coords_X_textbox.text())
        self.reference_coords_Y = float(self.reference_coords_Y_textbox.text())

        points = self.create_random_points()
        self.generate_time_series(points)

        self.command_line.append("Model created")

    def create_random_points(self):
	
        if self.min_distance > self.max_distance:
            raise ValueError("Minimum distance cannot be greater than maximum distance")
        
        points = []
        # Generate the first point 
         
        points.append((self.reference_coords_X , self.reference_coords_Y ))

        for i in range(1, self.points_amount):
            # Generate a random direction (angle in radians)
            direction = np.random.uniform(0, 2 * math.pi)

            # Generate a random distance within the specified range
            distance = np.random.uniform(self.min_distance, self.max_distance)

            # Calculate the new point's coordinates
            prev_x, prev_y = points[-1]
            new_x = prev_x + distance * math.cos(direction)
            new_y = prev_y + distance * math.sin(direction)

            points.append((new_x, new_y))

        return points

    def generate_time_series(self, points):
        data = []

        for i, point in enumerate(points):
            lat, lon = point
            station_name = ''.join(np.random.choice(list('ABCDEFGHIJKLMNOPQRSTUVWXYZ'), 4))

            height = np.random.uniform(0, 100)

            data.append({'Station': station_name,
                         'Latitude': lat,
                         'Longitude': lon,
                         'Height': height})

        df = pd.DataFrame(data)
        self.temp_file_xyz_name = os.path.join(self.data_dir, 'temp_xyz.csv')
        df.to_csv(self.temp_file_xyz_name, sep=';', index=False)

        self.command_line.append(f"Time series generated and saved to file: {self.temp_file_xyz_name}")

    def btn2_press(self):
        try:
            if not self.temp_file_xyz_name:
                self.command_line.append("No CSV file loaded. Please load a CSV file first.")
                return

            doc = FreeCAD.newDocument("NetworkMap")
            data = pd.read_csv(self.temp_file_xyz_name, delimiter=';')

            points = np.array(data[['Longitude', 'Latitude']])
            labels = data['Station'].astype(str).values

            # Create a KDTree for efficient nearest neighbor search
            tree = KDTree(points)

            max_vector_length = self.max_distance  # adjust this value to set the maximum vector length
            edges = set()
            # Get all edges of the triangles and add them to the set edges
            for n in range(len(points)):
                simplex = Delaunay(points).simplices[n]
                for i in range(3):
                    for j in range(i, 3):
                        if i != j:
                            edges.add((simplex[i], simplex[j]))

            # Connect only neighboring points
            for edge in edges:
                point1 = points[edge[0]]
                point2 = points[edge[1]]
                distance = np.linalg.norm(point1 - point2)
                if distance <= max_vector_length:
                    # Create a line between the two points
                    line = Part.makeLine(FreeCAD.Vector(*point1), FreeCAD.Vector(*point2))
                    Part.show(line)

                    # Add text label for the line length
                    midpoint = ((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2, 0)
                    text = Draft.make_text([f"{distance:.0f} m"], FreeCAD.Vector(*midpoint))
                    if text is not None:
                        text.ViewObject.FontSize = 1000

            # Create points and labels in FreeCAD
            for i, point in enumerate(points):
                label = labels[i]

                # Create a vertex object
                point_obj = Part.Vertex(FreeCAD.Vector(*point))
                Part.show(point_obj)

                # Create a text label for the point
                offset = FreeCAD.Vector(0.01, 0.01, 0)
                text_position = FreeCAD.Vector(point[0], point[1], 0) + offset
                text = Draft.make_text([label], text_position)
                if text is not None:
                    text.ViewObject.FontSize = 2000  # Размер шрифта названий пунктов


            FreeCADGui.activeDocument().activeView().viewAxometric()
            FreeCADGui.SendMsgToActiveView("ViewFit")
        except Exception as e:
            self.command_line.append(f'Error generating network map: {e}')

    def btn3_press(self):
        try:
            save_path, _ = QFileDialog.getSaveFileName(self, "Save File", "", "CSV Files (*.csv)")
            if save_path:
                shutil.copyfile(self.temp_file_xyz_name, save_path)
                self.command_line.append("File saved.")
        except Exception as e:
            self.command_line.append(f'Error saving file: {e}')

    def calculate_distance(self, x1, y1, x2, y2):
        return math.sqrt((x2 - x1)**2 + (y2 - y1)**2)

if __name__ == '__main__':
    main_window = MyWindow()
    main_window.exec_()
